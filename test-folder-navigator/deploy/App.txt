<!DOCTYPE html>
<html>
<head>
    <title>Test Folder Navigator</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Apr 09 2015 17:26:18 GMT-0700 (PDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Apr 09 2015 17:26:18 GMT-0700 (PDT)";
        var CHECKSUM = 33860919856;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('Rally.ui.menu.bulk.TestSet', {
    alias: 'widget.rallyrecordmenubulktestset',
    extend:  Rally.ui.menu.bulk.MenuItem ,


    config: {
        text: 'Add to TestSet...',
        handler: function() {
            this._onMenuItemChosen();
        },
        
        predicate: function(records) {
            return records;
        },

        prepareRecords: function(records, args) {
            return records;
        }      
    },     

    _onMenuItemChosen: function() {
        Ext.create('Rally.technicalservices.dialog.BulkAddToTestSetDialog', {
            listeners: {
                artifactchosen: this._testsetchosen,
                scope: this
            }
        });
        
        console.log('created dialog');
    },     

    _testsetchosen: function(dialog, testset) {
        console.log('Chose test set:',testset);
        var me = this;
        
        if (this.onBeforeAction(this.records) === false) {
            return;
        }
        var records = this.records;
        
        var promises = [];
        Ext.Array.each( records, function(record){
            promises.push( function(){
                return me._addToTestSet(record,testset);
            });
        },this);
        
        Deft.Chain.sequence(promises).then({
            scope: this,
            success: function(results) {
                console.log('done', results);
                this.onSuccess (Ext.Array.flatten(results), []);
            },
            failure: function(message) {
                Ext.Msg.alert('Problem saving to test set: ', message);
            }
        });
    },     
   
    // add one record at a time to the testset
    _addToTestSet: function(record, testset) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        console.log('Adding ', record.get('_type'), record.get('FormattedID'), testset.get('FormattedID'), testset.get('_ref'));
        if ( record.get('_type') == "testfolder" ) {
            // go get the testcases
            Deft.Chain.parallel([ 
                function() { return me._getTestFoldersInFolder(record) },
                function() { return me._getTestCasesInFolder(record) }
            ]).then({
                scope: me,
                success: function(folders_and_cases) {
                    var promises = [];
                    Ext.Array.each( Ext.Array.flatten(folders_and_cases), function(item){
                        promises.push( function(){
                            return me._addToTestSet(item,testset);
                        });
                    },this);
                    
                    Deft.Chain.sequence(promises).then({
                        scope: this,
                        success: function(results) {
                            deferred.resolve(results);
                        },
                        failure: function(message) {
                            deferred.reject(message);
                        }
                    });
                },
                failure: function(message) {
                    deferred.reject(message);
                }
            });
            
        } else {
            // add the testcase
            var store = testset.getCollection('TestCases');
            store.load({
                callback: function() {
                    console.log('adding ', record.get('_ref'), ' to ', store);
                    store.add([{ "_ref": record.get('_ref') }]);
                    store.sync({
                        callback: function() {
                            deferred.resolve(record);
                        }
                    });
                }
            });
        }
        return deferred.promise;
    },
    _getTestCasesInFolder: function(record) {
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            model: 'TestCase',
            autoLoad: true,
            filters: [{property:'TestFolder.ObjectID',value:record.get('ObjectID')}],
            limit: 'Infinity',
            listeners: {
                load: function(store,records,success){
                    deferred.resolve(records);
                }
            }
        });
        
        return deferred.promise;
    },
    _getTestFoldersInFolder: function(record) {
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            model: 'TestFolder',
            autoLoad: true,
            filters: [{property:'Parent.ObjectID',value:record.get('ObjectID')}],
            limit: 'Infinity',
            listeners: {
                load: function(store,records,success){
                    deferred.resolve(records);
                }
            }
        });
        
        return deferred.promise;
    },
    /**    
     * @override
     * @inheritdoc
     */     
    onSuccess: function (successfulRecords, unsuccessfulRecords, args, errorMessage) {
        var changes = {};
        Ext.callback(this.onActionComplete, null, [successfulRecords, unsuccessfulRecords, changes]);
    }
});

Ext.define('Rally.technicalservices.ui.menu.item.CascadeDeleteMenuItem', {
    extend:  Rally.ui.menu.item.RecordMenuItem ,
    alias: 'widget.tsrecordmenuitemcascadedelete',

    clickHideDelay: 1,

    config: {

        /**
         * @cfg {Rally.data.wsapi.Model}
         * The record of the menu
         */
        record: undefined,

        /**
         * @cfg {Function}
         * This is called when a menu item is clicked
         */
        handler: function () {
            this._onCascadeDeleteClicked();
        },

        /**
         * @cfg {Function}
         *
         * A function that should return true if this menu item should show.
         * @param record {Rally.data.wsapi.Model}
         * @return {Boolean}
         */
        predicate: function (record) {
            return true;
        },

        /**
         * @cfg {String}
         * The display string
         */
        text: 'Cascade Delete'

    },

    constructor:function (config) {
        this.initConfig(config);
        this.callParent(arguments);
    },
    
    _onCascadeDeleteClicked: function() {
        var confirm_dialog = this._launchConfirmDialog();
        confirm_dialog.on('confirm',this._doDelete, this);
    },
    
    _doDelete: function() {
        var me = this;
        this.view.setLoading("Finding Records To Remove");
        
        this._getChildren(this.record).then({
            success: function(results) {                
                var testfolders = results[0];
                var testcases = Ext.Array.flatten(results[1]);
                
                var promises = [];
                Ext.Array.each(testcases, function(record) {
                    promises.push( function() { return me._destroyRecord(record); } );
                });
                
                Ext.Array.each(testfolders, function(record) {
                    promises.push( function() { return me._destroyRecord(record); } );
                });
                
                me.view.setLoading("Removing " + promises.length + " records");
                
                Deft.Chain.sequence(promises).then({
                    success: function(results) {
                        me.view.setLoading(false);
                    },
                    failure: function(message) {
                        Ext.msg.alert(message);
                    }
                });
            },
            failure: function(message) {
                Ext.msg.alert(message);
            }
        });
        
    },
    
    _destroyRecord: function(record) {
        var deferred = Ext.create('Deft.Deferred');
        record.destroy({
            callback: function(result,operation) {
                if (operation.wasSuccessful()) {
                    deferred.resolve(1);
                } else {
                    console.log(record.get("FormattedID"), operation);
                    deferred.reject("Could not destroy " + record.get('FormattedID'));
                }
            }
        });
        return deferred.promise;
    },
    
    _getChildren: function(record) {
        var deferred = Ext.create('Deft.Deferred');
        
        var testfolders = [record];  // TODO: stop cheating
        var me = this;
        
        Deft.Chain.pipeline([
            function() { return me._getChildTestFolders(record,testfolders); },
            function(results) {
                var d2 = Ext.create('Deft.Deferred');
                var promises = [];
                
                Ext.Array.each(testfolders,function(testfolder){
                    promises.push(me._getChildTestCases(testfolder));
                });
                
                Deft.Promise.all(promises).then({
                    success: function(results) { d2.resolve([testfolders,results]) },
                    failure: function(message) { d2.reject(message) }
                });
                return d2.promise;
            }
        ]).then({
            scope: this,
            success: function(results) {
                deferred.resolve(results);
            },
            failure: function(message) {
                deferred.reject(message);
            }
        });
        return deferred.promise;
    },
    
    _getChildTestCases: function(testfolder) {
        var deferred = Ext.create('Deft.Deferred');
        
        Ext.create('Rally.data.wsapi.Store',{
            limit: 'Infinity',
            model:'TestCase',
            filters: [{property:'TestFolder',value: testfolder.get('_ref')}],
            autoLoad: true,
            fetch: ['FormattedID'],
            listeners: {
                scope: this,
                load: function(store,records) {
                    deferred.resolve(records);
                }
            }
        });
        return deferred.promise;
    },
    
    _getChildTestFolders: function(record,children) {
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            limit: 'Infinity',
            model:'TestFolder',
            filters: [{property:'Parent',value: record.get('_ref')}],
            autoLoad: true,
            fetch: ['FormattedID'],
            listeners: {
                scope: this,
                load: function(store,records) {
                    var promises = [];
                    Ext.Array.each(records,function(record){
                        children.push(record);
                        promises.push(this._getChildTestFolders(record,children));
                    },this);
                    if ( promises.length > 0 ) {
                        Deft.Promise.all(promises).then({
                            success: function(more_records) {
                                children = Ext.Array.merge(children,more_records);
                                deferred.resolve(children);
                            },
                            failure: deferred.reject
                        });
                    } else {
                        //children.push(record);
                        deferred.resolve(children);
                    }
                }
            }
        });
        return deferred.promise;
    },
    
    _launchConfirmDialog: function() {
        return Ext.create('Rally.ui.dialog.ConfirmDialog', {
            title: 'Cascade Delete',
            message: "Are you sure? <br/><br/>This will delete <em>all of</em> this folder's descendant folders and test cases, regardless of your filter setting.<br/><br/>  THERE IS NO UNDO.",
            confirmLabel: 'OK'
        });
    }
});
Ext.override(Rally.ui.grid.CheckboxModel,{

    _recordIsSelectable: function(record) {
        return true;
    }
            
});

Ext.override(Rally.ui.menu.bulk.RecordMenu,{

    _getMenuItems: function () {
        var records = this.getRecords();
        var items = [
            {
                text: 'Bulk Actions (' + records.length + ' items)',
                canActivate: false,
                cls: 'menu-item-read-only'
            }
        ].concat(this.items);

        items.push({xtype: 'rallyrecordmenubulktestset'});
  

        _.each(items, function (item) {
            Ext.apply(item, {
                records: records,
                store: this.store,
                onBeforeAction: this.onBeforeAction,
                onActionComplete: this.onActionComplete,
                context: this.getContext()
            });
        }, this);

        return items;
    }
});

Ext.override(Rally.ui.gridboard.GridBoard,{
        
    _applyGridFilters: function(grid, filterObj) {
        if (!_.isEmpty(filterObj.types)) {
            grid.store.parentTypes = filterObj.types;
        }
        console.log("FILTER: ", filterObj);
        console.log("FILTER +:", this._getConfiguredFilters(filterObj.filters || [], filterObj.types || []));
        grid.store.clearFilter(true);
        grid.store.filter(this._getConfiguredFilters(filterObj.filters || [], filterObj.types || []));
    },
    
    _getConfiguredFilters: function(extraFilters, types) {
        var isBoard = this.getToggleState() === 'board';
        
        
        // want to see if we can decide to only apply the permanent filter if extra is empty
        console.log("EXTRA filters:", extraFilters);
        
        var filters =  _.compact(Ext.Array.merge(
                    this.storeConfig && this.storeConfig.filters,
                    isBoard && this.cardBoardConfig.storeConfig && this.cardBoardConfig.storeConfig.filters,
                    !isBoard && this.gridConfig.storeConfig && this.gridConfig.storeConfig.filters,
                    extraFilters));
                    
        if ( extraFilters.length != 0 ) {
            filters = extraFilters;
        }

        console.log("FILTERS:", filters);
        
        return filters;
    }
        
});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    /**
     * 
     * @param {String} A prefix to put into the message between
     *      the timestamp and the message
     */
    class_prefix: null,
    
    constructor: function(config){
        Ext.apply(this,config);
    },
    
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args.push(this._getClassPrefix(this.class_prefix));
        
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    },
    
    _getClassPrefix: function(prefix) {
        display_prefix = "";
        if ( Ext.isString(prefix) ) {
            display_prefix = "-" + prefix + "-";
        }
        
        return display_prefix;
    }

});

Ext.override(Rally.ui.menu.DefaultRecordMenu, {
    _getMenuItems: function() {
        var record = this.getRecord();
        var items = [];
        
        items.push({
            xtype: 'tsrecordmenuitemcascadedelete',
            view: this.view,
            record: record
        });
        
        return items;
    }
});

Ext.override(Rally.ui.menu.TestCaseRecordMenu, {
    _getMenuItems: function() {
        var record = this.getRecord();
        var items = [];
        
//        items.push({
//            xtype: 'tsrecordmenuitemcascadedelete',
//            view: this.view,
//            record: record
//        });
        
        return items;
    }
});
Ext.override(Ext.data.TreeStore,{
    load: function(options) {        
        options = options || {};
        options.params = options.params || {};

        var me = this,
            node = options.node || me.tree.getRootNode(),
            callback = options.callback,
            scope = options.scope,
            operation;

        // If there is not a node it means the user hasnt defined a rootnode yet. In this case let's just
        // create one for them.
        if (!node) {
            node = me.setRootNode({
                expanded: true
            }, true);
        }

        // If the node we are loading was expanded, we have to expand it after the load
        if (node.data.expanded) {
            node.data.loaded = false;

            // Must set expanded to false otherwise the onProxyLoad->fillNode->appendChild calls will update the view.
            // We ned to update the view in the callback below.
            if (me.clearOnLoad) {
                node.data.expanded = false;
            }
            options.callback = function() {

                // If newly loaded nodes are to be added to the existing child node set, then we have to collapse
                // first so that they get removed from the NodeStore, and the subsequent expand will reveal the
                // newly augmented child node set.
                if (!me.clearOnLoad) {
                    node.collapse();
                }
                node.expand();

                // Call the original callback (if any)
                Ext.callback(callback, scope, arguments);
            }
        }

        // Assign the ID of the Operation so that a ServerProxy can set its idParam parameter,
        // or a REST proxy can create the correct URL
        options.id = node.getId();

        options = Ext.apply({
            action: 'read',
            filters: me.filters.items,
            sorters: me.getSorters(),
            node: options.node || node
        }, options);

        me.lastOptions = options;

        operation = new Ext.data.Operation(options);

        if (me.fireEvent('beforeload', me, operation) !== false) {
             if (me.clearOnLoad) {
                if(me.clearRemovedOnLoad) {
                    // clear from the removed array any nodes that were descendants of the node being reloaded so that they do not get saved on next sync.
                    me.clearRemoved(node);
                }
                // temporarily remove the onNodeRemove event listener so that when removeAll is called, the removed nodes do not get added to the removed array
                me.tree.un('remove', me.onNodeRemove, me);
                // remove all the nodes
                node.removeAll(false);
                // reattach the onNodeRemove listener
                me.tree.on('remove', me.onNodeRemove, me);
            }
            me.loading = true;

            if ( !me.isRootNode(options.node) && me.models && me.models.length == 2 ) {
                /* If we have two models and they 
                 * don't both descend from the artifact 
                 * type (like test folder), we want to run
                 * the query twice and combine the results.
                 * 
                 * We have to make two new operations because
                 * each run modifies it
                 */
                console.log('taking alternate route');
                
                var o1 = Ext.create('Ext.data.Operation', options);
                o1.id = null;
                var o2 = Ext.create('Ext.data.Operation', options);
                o2.id = null;
                
                Deft.Chain.sequence([
                    function() {
                        var deferred = Ext.create('Deft.Deferred');
                        var model = me.models[1];
                        
                        o1.filters = me.filter_by_model[model.typePath];
                        model.getProxy().read(o1,function(op){
                            deferred.resolve(op);
                        },me);
                        
                        return deferred.promise;
                    },
                    function() {
                        var deferred = Ext.create('Deft.Deferred');
                        var model = me.models[0];
                        
                        o2.filters = me.filter_by_model[model.typePath];
                        model.getProxy().read(o2,function(op){
                            deferred.resolve(op);
                        },me);
                        
                        return deferred.promise;
                    }
                ]).then({
                    scope: me,
                    success: function(operation){
                        var records = Ext.Array.merge(operation[0].getRecords(), operation[1].getRecords());
                        var results = Ext.create('Ext.data.ResultSet',{ records: records });
                        
                        operation[0].resultSet = results;
                        
                        me.onProxyLoad(operation[0]);
                    },
                    failure: function(msg){
                        alert(msg);
                    }
                
                });
                
            } else {
                me.proxy.read(operation, me.onProxyLoad, me);
            }
        }

        if (me.loading && node) {
            node.set('loading', true);
        }

        return me;
    }
});

Ext.override(Rally.data.wsapi.TreeStore,{
    
    load: function(options) {
        this.recordLoadBegin({description: 'tree store load', component: this.requester});
        
        this._hasErrors = false;

        this.on('beforeload', function(store, operation) {
            delete operation.id;
        }, this, { single: true });

        options = this._configureLoad(options);
        options.originalCallback = options.callback;

        var deferred = Ext.create('Deft.Deferred'),
            me = this;

        options.callback = function (records, operation, success) {
            me.dataLoaded = true;

            if(me.isRootNode(options.node) && operation.resultSet && operation.resultSet.sums) {
                me.setSums(operation.resultSet.sums);
            }

            if (me._pageIsEmpty(operation)) {
                me._reloadEmptyPage(options).then({
                    success: function (records) {
                        me._resolveLoadingRecords(deferred, records, options, operation, success);
                    },
                    failure: function() {
                        me._rejectLoadingRecord(deferred, options, operation);
                    }
                });
            } else {
                me._resolveLoadingRecords(deferred, records, options, operation, success);
            }
        };

        if (this._isViewReady()) {
            this._beforeInitialLoad(options);
        }

        this.callParent([options]);
        
        return deferred.promise;
    },
    // when we run the queries, need to consolidate the results
    temp_records: null, 
    
    _resolveLoadingRecords: function(deferred, records, options, operation, success) {
        delete options.callback; // Don't call me again, Susan.

        if ( ! this.temp_records || this.temp_records == null) { 
            this.temp_records = records; 
        } else {
            records = Ext.Array.merge(this.temp_records,records);
            this.temp_records = null;
            this.fred = false;
            
            if (options.originalCallback) {
                Ext.callback(options.originalCallback, options.scope || this, [records, operation, success]);
            }

            deferred.resolve(records);
        }
    },
    
    filter_by_model: {},
    
    _getChildNodeFilters: function(node) {
        
        var parentType = node.self.typePath,
            childTypes = this._getChildTypePaths([parentType]),
            parentFieldNames = this._getParentFieldNames(childTypes, parentType);

        Ext.Array.each(childTypes, function(childType){            
            var parentFieldName = this.mapper.getParentFieldForChild(childType,parentType);
            
            if ( parentFieldName ) {
                this.filter_by_model[childType] = [ Ext.create('Rally.data.wsapi.Filter',{
                    property: parentFieldName,
                    operator: '=',
                    value: node.get('_ref')
                }) ];
            }
        },this);
        
        if (parentFieldNames.length) {
            return [
                Rally.data.wsapi.Filter.or(_.map(parentFieldNames, function(parentFieldName) {
                    return {
                        property: parentFieldName,
                        operator: '=',
                        value: node.get('_ref')
                    };
                }))
            ];
        }
        
        return [];
    }
});

// test folders aren't artifacts
Ext.override(Rally.data.wsapi.ModelBuilder,{
    buildCompositeArtifact: function(models, context, wsapiVersion) {
        
        var typePath = 'testfolder',
            displayName = 'TestFolder',
            typeDefMetaData = Ext.create('Rally.data.TypeDefinitionMetaData', {
                requested: typePath,
                context: context,
                wsapiVersion: wsapiVersion
            }),
            typeDefinition = {
                Attributes: this._getAttributeDefinitionsFromModels(models),
                TypePath: typePath,
                DisplayName: displayName,
                Parent: null,
                ElementName: displayName,
                Restorable: false
            };
        
        var model = this.build(typeDefMetaData, typeDefinition);

        model.getArtifactComponentModels = function() {
            return models;
        };

        model.getModelsForField = function(field) {
            return _.transform(this.getArtifactComponentModels(), function(matchingModels, model) {
                if (_.find(model.getFields(), {name: field.name})){
                   matchingModels.push(model);
                }
            }, []);
        };

        var modelsByType = _.indexBy(model.getArtifactComponentModels(), 'typeName');
        
        model.getArtifactComponentModel = function(type) {
            var canonicalType = type.toLowerCase();
            return modelsByType[canonicalType];
        };
        return model;
    },
    
    /*
     * given the typedef response from the wsapi, build an Ext Model
     * @param {Rally.data.TypeDefinitionMetaData} typeDefMetaData TypeDefinition MetaData
     * @param {Object} typeDefinition The JSON representation of a Type Definition as
     *                                responded by the server
     */
    build: function(typeDefMetaData, typeDefinition) {
        var attributes = typeDefinition.Attributes,
            commonWsapiFields = _.map(
                Rally.data.FieldFactory.getCommonWsapiFields().concat(Rally.data.FieldFactory.getVirtualWsapiFields(typeDefinition)),
                this._createWsapiField
            ),
            fields = commonWsapiFields.concat(
                Rally.data.FieldFactory.buildFieldsFromTypeDefinitionAttributes(attributes)
            ),
            validations = Rally.data.FieldFactory.buildValidationsFromTypeDefinitionAttributes(attributes),
            typePath = typeDefinition.TypePath,
            metadataTypePath = typeDefMetaData.getTypePath().toLowerCase();

        _.each(fields, function(field) {
            field.modelType = typePath.toLowerCase();
        });

        return Ext.define(typeDefMetaData.getFullyQualifiedName(), {
            extend: 'Rally.data.wsapi.Model',
                fields: fields,
                validations: validations,
                statics: {
                    /**
                     * E.g., 'hierarchicalrequirement' or 'defect' or 'testcase'
                     */
                    typeName: metadataTypePath,

                    /**
                     * Type typeName, but replaces hierarchicalrequirment with userstory. Useful when building URLs
                     */
                    prettyTypeName: metadataTypePath === 'hierarchicalrequirement' ? 'userstory' : metadataTypePath,

                    /**
                     * E.g., 'portfolioitem/theme' or 'defect'
                     */
                    typePath: typePath.toLowerCase(),

                    /**
                     * E.g., 'User Story'
                     */
                    displayName: typeDefinition.DisplayName,

                    /**
                     * E.g., 'Portfolio Item' if a Theme
                     */
                    parentTypeName: typeDefinition.Parent && typeDefinition.Parent._refObjectName,

                    /**
                     * E.g., 'Theme' or 'HierarchicalRequirement'
                     */
                    elementName: typeDefinition.ElementName,

                    /**
                     * If a Dynamic Type (like Feature, a type of Portfolio Item), contains the level, e.g. 0 if the lowest
                     * -1 if not a dynamic type, like Defect.
                     */
                    ordinal: typeDefinition.Ordinal,
                    /**
                     * E.g.
                     * { workspace: '/workspace/123' }
                     */
                    context: typeDefMetaData.context,
                    /**
                     * E.g. true if a delete of this type should move it to the recycle bin
                     */
                    restorable: typeDefinition.Restorable,

                    /**
                     * E.g. 1.37 - the wsapi version from which this model was built
                     */
                    wsapiVersion: typeDefMetaData.wsapiVersion,

                    /**
                     * The ObjectID of the type definition the model was built by
                     */
                    typeDefOid: typeDefinition.ObjectID,

                    /**
                     * The name of type definition
                     */
                    typeDefName: typeDefinition.Name
                },

                proxy: Rally.data.wsapi.ModelFactory.buildProxy(Rally.data.wsapi.ModelFactory.buildProxyUrl(typePath, typeDefMetaData.wsapiVersion), typeDefinition.ElementName, null, typeDefMetaData.wsapiVersion)
            });
    }
});

// override treegrid so that all the models can be given to the picker
Ext.override(Rally.ui.grid.TreeGrid, {
    getModels: function() {
        console.log('store:',this.store);
        
        return this.store.models || [this.store.model];
    }
});
Ext.define('Rally.technicalservices.dialog.BulkAddToTestSetDialog',{
    extend: 'Rally.ui.dialog.ArtifactChooserDialog',
    alias: 'widget.tsaddtotestsetdialog',
    
    config: {
        autoShow: true,
        title: 'Choose a TestSet',
        artifactTypes: 'TestSet',
        multiple: false,
        
        columns: [
            {
                text: 'ID',
                dataIndex: 'FormattedID',
                renderer: _.identity
            },
            'Name',
            'Iteration',
            'Project'
        ]
    }
    
});
Ext.define('Rally.technicalservices.TFParentChildMapper',{
    extend: 'Rally.data.wsapi.ParentChildMapper',
    constructor: function() {
        this.parentChildTypeMap = {
            testfolder: [
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestFolder'},
                {typePath: 'testfolder', collectionName: 'Children', parentField: 'Parent'}
            ],
            hierarchicalrequirement: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'Requirement'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'},
                {typePath: 'hierarchicalrequirement', collectionName: 'Children', parentField: 'Parent'}
            ],
            defect: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            defectsuite: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'DefectSuites'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            testset: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestSets'}
            ]
        };
    },
    
    getParentFieldForChild: function(childType,parentType) {        
        var map_array = this.parentChildTypeMap[parentType];
        var parent_field = null;
        if (map_array) {
            Ext.Array.each(map_array, function(map){
                if ( map.typePath == childType && map.parentField ) {
                    parent_field =  map.parentField;
                }
            });
        }
        
        return parent_field;
        
    }
});

Ext.define('TestFolderNavigator', {
        extend: 'Rally.app.GridBoardApp',
        requires: [
            'Rally.ui.DateField'
        ],
        cls: 'testfolder-app',
        modelNames: ['TestFolder'],
        statePrefix: 'ts-testfolder',

        logger: Ext.create('Rally.technicalservices.Logger'),
        
        getPermanentFilters: function () {
            return [
                Rally.data.wsapi.Filter.or([
                    { property: 'Parent', operator: '=', value: "" }
                ])
            ];
        },

        getFieldPickerConfig: function () {
            var config = this.callParent(arguments);
            config.gridFieldBlackList = _.union(config.gridFieldBlackList, [
                'VersionId',
                'Parent',
                'TestCases',
                'Recycled',
                'TestFolder',
                'Steps',
                'Objective',
                'PostConditions',
                'PreConditions',
                'Results',
                'TestSets',
                'ValidationExpectedResult',
                'ValidationInput'
            ]);
            return _.merge(config, {
               _getModels: function() {
                    console.log('models for picker', this.cmp.getModels());
                    
                    return _.reduce(this.cmp.getModels(), function(accum, model) {
                        if (model.typePath === 'artifact') {
                            accum = accum.concat(model.getArtifactComponentModels());
                        } else {
                            accum.push(model);
                        }
                        return accum;
                    }, []);
                },
                gridAlwaysSelectedValues: ['FormattedID','Name']
            });
        },
        
        getGridStores: function () {
            return this._getTreeGridStore();
        },
        
        _getTreeGridStore: function () {
            return Ext.create('Rally.data.wsapi.TreeStoreBuilder').build(_.merge({
                autoLoad: false,
                sorters: [{ property: 'ObjectID', direction: 'ASC'}],
                childPageSizeEnabled: true,
                mapper: Ext.create('Rally.technicalservices.TFParentChildMapper'),
                enableHierarchy: true,
                fetch: _.union(['Workspace'], this.columnNames),
                models: _.clone(this.models),
                pageSize: 25,
                remoteSort: true,
                root: {expanded: true},
//                storeType: 'Rally.technicalservices.data.wsapi.testfolder.Store',
                getParentFieldNamesByChildType: this._getParentFieldNamesByChildType,
                childLevelSorters: [{ property: 'FormattedID',direction: 'ASC'}]

            }, this.getGridStoreConfig())).then({
                success: function (treeGridStore) {
                    this.logger.log(treeGridStore);
                    treeGridStore.enableHierarchy = true;
                    //treeGridStore.on('load', this.publishComponentReady, this, { single: true });
                    return { gridStore: treeGridStore };
                },
                scope: this
            });
        },

        _getParentFieldNamesByChildType: function(childType, parentType) {
            var model = this.model.getArtifactComponentModel(childType);
            return(['Parent']);
            return _.transform(this.mapper.getParentFields(childType, parentType), function(acc, field) {
                var typePath = field.typePath,
                    fieldName = field.fieldName,
                    hasFieldModel = this.model.getArtifactComponentModel(typePath) || model.hasField(fieldName);

                if (hasFieldModel) {
                    acc.push(fieldName.replace(/\s+/g, ''));
                }
            }, [], this);
            
        },
        
        getAddNewConfig: function () {
            return Ext.merge(this.callParent(arguments), {
                showRank: false,
                showAddWithDetails: false,
                openEditorAfterAddFailure: false,
                minWidth: 800
            });
        },
        
        getGridBoardPlugins: function () {
            return [
//                {
//                    ptype: 'rallygridboardaddnew',
//                    context: this.getContext()
//                },
                {
                    ptype: 'rallygridboardcustomfiltercontrol',
                    filterChildren: false,
                    filterControlConfig: _.merge({
                        modelNames: this.modelNames,
                        stateful: true,
                        stateId: this.getScopedStateId('custom-filter-button')
                    }, this.getFilterControlConfig()),
                    showOwnerFilter: false,
                    ownerFilterControlConfig: {
                        stateful: true,
                        stateId: this.getScopedStateId('owner-filter')
                    }
                },
                _.merge({
                    ptype: 'rallygridboardfieldpicker',
                    headerPosition: 'left'
                }, this.getFieldPickerConfig())
            ]
            .concat(this.enableGridBoardToggle ? 'rallygridboardtoggleable' : [])/*
            .concat(this.getActionsMenuConfig())*/;
        },

        getGridConfig: function (options) {
            return {
                xtype: 'rallytreegrid',
                alwaysShowDefaultColumns: false,
                columnCfgs: this.getColumnCfgs(),
                enableBulkEdit: true,
                enableRanking: Rally.data.ModelTypes.areArtifacts(this.modelNames),
                expandAllInColumnHeaderEnabled: true,
                plugins: this.getGridPlugins(),
                stateId: this.getScopedStateId('grid'),
                stateful: true,
                store: options && options.gridStore,
                storeConfig: {
                    filters: this.getPermanentFilters()
                },
                summaryColumns: [],
                listeners: {
                    afterrender: this.publishComponentReady,
                    storeload: {
                        fn: function () {
                            this.fireEvent('contentupdated', this);
                        },
                        single: true
                    },
                    scope: this
                }
            };
        }
    });
            
               Rally.launchApp('TestFolderNavigator', {
                   name: 'Test Folder Navigator'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>
<!DOCTYPE html>
<html>
<head>
    <title>Test Folder Navigator</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Tue Jun 09 2015 14:37:41 GMT-0700 (PDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Tue Jun 09 2015 14:37:41 GMT-0700 (PDT)";
        var CHECKSUM = 73822933919;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('Rally.ui.menu.bulk.TestSet', {
    alias: 'widget.rallyrecordmenubulktestset',
    extend:  Rally.ui.menu.bulk.MenuItem ,


    config: {
        text: 'Add to TestSet...',
        handler: function() {
            this._onMenuItemChosen();
        },
        
        predicate: function(records) {
            return records;
        },

        prepareRecords: function(records, args) {
            return records;
        }      
    },     

    _onMenuItemChosen: function() {
        Ext.create('Rally.technicalservices.dialog.BulkAddToTestSetDialog', {
            listeners: {
                artifactchosen: this._testsetchosen,
                scope: this
            }
        });
        
        console.log('created dialog');
    },     

    _testsetchosen: function(dialog, testset) {
        console.log('Chose test set:',testset);
        var me = this;
        
        if (this.onBeforeAction(this.records) === false) {
            return;
        }
        var records = this.records;
        
        var promises = [];
        Ext.Array.each( records, function(record){
            promises.push( function(){
                return me._addToTestSet(record,testset);
            });
        },this);
        
        Deft.Chain.sequence(promises).then({
            scope: this,
            success: function(results) {
                console.log('done', results);
                this.onSuccess (Ext.Array.flatten(results), []);
            },
            failure: function(message) {
                Ext.Msg.alert('Problem saving to test set: ', message);
            }
        });
    },     
   
    // add one record at a time to the testset
    _addToTestSet: function(record, testset) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        console.log('Adding ', record.get('_type'), record.get('FormattedID'), testset.get('FormattedID'), testset.get('_ref'));
        if ( record.get('_type') == "testfolder" ) {
            // go get the testcases
            Deft.Chain.parallel([ 
                function() { return me._getTestFoldersInFolder(record) },
                function() { return me._getTestCasesInFolder(record) }
            ]).then({
                scope: me,
                success: function(folders_and_cases) {
                    var promises = [];
                    Ext.Array.each( Ext.Array.flatten(folders_and_cases), function(item){
                        promises.push( function(){
                            return me._addToTestSet(item,testset);
                        });
                    },this);
                    
                    Deft.Chain.sequence(promises).then({
                        scope: this,
                        success: function(results) {
                            deferred.resolve(results);
                        },
                        failure: function(message) {
                            deferred.reject(message);
                        }
                    });
                },
                failure: function(message) {
                    deferred.reject(message);
                }
            });
            
        } else {
            // add the testcase
            var store = testset.getCollection('TestCases');
            store.load({
                callback: function() {
                    console.log('adding ', record.get('_ref'), ' to ', store);
                    store.add([{ "_ref": record.get('_ref') }]);
                    store.sync({
                        callback: function() {
                            deferred.resolve(record);
                        }
                    });
                }
            });
        }
        return deferred.promise;
    },
    _getTestCasesInFolder: function(record) {
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            model: 'TestCase',
            autoLoad: true,
            filters: [{property:'TestFolder.ObjectID',value:record.get('ObjectID')}],
            sorters: [{property:'DragAndDropRank',direction:'ASC'}],
            limit: 'Infinity',
            listeners: {
                load: function(store,records,success){
                    Ext.Array.each(records,function(record){ console.log(record.get('FormattedID')); });
                    
                    deferred.resolve(records);
                }
            }
        });
        
        return deferred.promise;
    },
    _getTestFoldersInFolder: function(record) {
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            model: 'TestFolder',
            autoLoad: true,
            filters: [{property:'Parent.ObjectID',value:record.get('ObjectID')}],
            limit: 'Infinity',
            listeners: {
                load: function(store,records,success){
                    deferred.resolve(records);
                }
            }
        });
        
        return deferred.promise;
    },
    /**    
     * @override
     * @inheritdoc
     */     
    onSuccess: function (successfulRecords, unsuccessfulRecords, args, errorMessage) {
        var changes = {};
        Ext.callback(this.onActionComplete, null, [successfulRecords, unsuccessfulRecords, changes]);
    }
});

Ext.define('Rally.technicalservices.ui.menu.item.CascadeDeleteMenuItem', {
    extend:  Rally.ui.menu.item.RecordMenuItem ,
    alias: 'widget.tsrecordmenuitemcascadedelete',

    clickHideDelay: 1,

    config: {

        /**
         * @cfg {Rally.data.wsapi.Model}
         * The record of the menu
         */
        record: undefined,

        /**
         * @cfg {Function}
         * This is called when a menu item is clicked
         */
        handler: function () {
            this._onCascadeDeleteClicked();
        },

        /**
         * @cfg {Function}
         *
         * A function that should return true if this menu item should show.
         * @param record {Rally.data.wsapi.Model}
         * @return {Boolean}
         */
        predicate: function (record) {
            return true;
        },

        /**
         * @cfg {String}
         * The display string
         */
        text: 'Cascade Delete'

    },

    constructor:function (config) {
        this.initConfig(config);
        this.callParent(arguments);
    },
    
    _onCascadeDeleteClicked: function() {
        var confirm_dialog = this._launchConfirmDialog();
        confirm_dialog.on('confirm',this._doDelete, this);
    },
    
    _doDelete: function() {
        var me = this;
        this.view.setLoading("Finding Records To Remove");
        
        this._getChildren(this.record).then({
            success: function(results) {                
                var testfolders = results[0];
                var testcases = Ext.Array.flatten(results[1]);
                
                var promises = [];
                Ext.Array.each(testcases, function(record) {
                    promises.push( function() { return me._destroyRecord(record); } );
                });
                
                Ext.Array.each(testfolders, function(record) {
                    promises.push( function() { return me._destroyRecord(record); } );
                });
                
                me.view.setLoading("Removing " + promises.length + " records");
                
                Deft.Chain.sequence(promises).then({
                    success: function(results) {
                        me.view.setLoading(false);
                    },
                    failure: function(message) {
                        Ext.msg.alert(message);
                    }
                });
            },
            failure: function(message) {
                Ext.msg.alert(message);
            }
        });
        
    },
    
    _destroyRecord: function(record) {
        var deferred = Ext.create('Deft.Deferred');
        record.destroy({
            callback: function(result,operation) {
                if (operation.wasSuccessful()) {
                    deferred.resolve(1);
                } else {
                    console.log(record.get("FormattedID"), operation);
                    deferred.reject("Could not destroy " + record.get('FormattedID'));
                }
            }
        });
        return deferred.promise;
    },
    
    _getChildren: function(record) {
        var deferred = Ext.create('Deft.Deferred');
        
        var testfolders = [record];  // TODO: stop cheating
        var me = this;
        
        Deft.Chain.pipeline([
            function() { return me._getChildTestFolders(record,testfolders); },
            function(results) {
                var d2 = Ext.create('Deft.Deferred');
                var promises = [];
                
                Ext.Array.each(testfolders,function(testfolder){
                    promises.push(me._getChildTestCases(testfolder));
                });
                
                Deft.Promise.all(promises).then({
                    success: function(results) { d2.resolve([testfolders,results]) },
                    failure: function(message) { d2.reject(message) }
                });
                return d2.promise;
            }
        ]).then({
            scope: this,
            success: function(results) {
                deferred.resolve(results);
            },
            failure: function(message) {
                deferred.reject(message);
            }
        });
        return deferred.promise;
    },
    
    _getChildTestCases: function(testfolder) {
        var deferred = Ext.create('Deft.Deferred');
        
        Ext.create('Rally.data.wsapi.Store',{
            limit: 'Infinity',
            model:'TestCase',
            filters: [{property:'TestFolder',value: testfolder.get('_ref')}],
            autoLoad: true,
            fetch: ['FormattedID'],
            listeners: {
                scope: this,
                load: function(store,records) {
                    deferred.resolve(records);
                }
            }
        });
        return deferred.promise;
    },
    
    _getChildTestFolders: function(record,children) {
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            limit: 'Infinity',
            model:'TestFolder',
            filters: [{property:'Parent',value: record.get('_ref')}],
            autoLoad: true,
            fetch: ['FormattedID'],
            listeners: {
                scope: this,
                load: function(store,records) {
                    var promises = [];
                    Ext.Array.each(records,function(record){
                        children.push(record);
                        promises.push(this._getChildTestFolders(record,children));
                    },this);
                    if ( promises.length > 0 ) {
                        Deft.Promise.all(promises).then({
                            success: function(more_records) {
                                children = Ext.Array.merge(children,more_records);
                                deferred.resolve(children);
                            },
                            failure: deferred.reject
                        });
                    } else {
                        //children.push(record);
                        deferred.resolve(children);
                    }
                }
            }
        });
        return deferred.promise;
    },
    
    _launchConfirmDialog: function() {
        return Ext.create('Rally.ui.dialog.ConfirmDialog', {
            title: 'Cascade Delete',
            message: "Are you sure? <br/><br/>This will delete <em>all of</em> this folder's descendant folders and test cases, regardless of your filter setting.<br/><br/>  THERE IS NO UNDO.",
            confirmLabel: 'OK'
        });
    }
});
Ext.override(Rally.ui.grid.CheckboxModel,{

    _recordIsSelectable: function(record) {
        return true;
    }
            
});

Ext.override(Rally.ui.menu.bulk.RecordMenu,{

    _getMenuItems: function () {
        var records = this.getRecords();
        var items = [
            {
                text: 'Bulk Actions (' + records.length + ' items)',
                canActivate: false,
                cls: 'menu-item-read-only'
            }
        ].concat(this.items);

        items.push({xtype: 'rallyrecordmenubulktestset'});
  

        _.each(items, function (item) {
            Ext.apply(item, {
                records: records,
                store: this.store,
                onBeforeAction: this.onBeforeAction,
                onActionComplete: this.onActionComplete,
                context: this.getContext()
            });
        }, this);

        return items;
    }
});

Ext.override(Rally.ui.gridboard.GridBoard,{
    
    _applyGridFilters: function(grid, filterObj) {
        if (!_.isEmpty(filterObj.types)) {
            grid.store.parentTypes = filterObj.types;
        }

        grid.store.clearFilter(true);
        grid.store.filter(this._getConfiguredFilters(filterObj.filters || [], filterObj.types || []));
    },
    
    _getConfiguredFilters: function(extraFilters, types) {
        var isBoard = this.getToggleState() === 'board';
        
        // want to see if we can decide to only apply the permanent filter if extra is empty
        if ( !extraFilters ) { extraFilters = []; }
        var filters =  _.compact(Ext.Array.merge(
                    this.storeConfig && this.storeConfig.filters,
                    isBoard && this.cardBoardConfig.storeConfig && this.cardBoardConfig.storeConfig.filters,
                    !isBoard && this.gridConfig.storeConfig && this.gridConfig.storeConfig.filters,
                    extraFilters));
                    
        if ( extraFilters.length != 0 ) {
            filters = extraFilters;
        }
        
        return filters;
    },

    _showRecord: function(item) {
        this.setLoading("Finding " + item.get("FormattedID") + "...");
        console.log("show", item);
        var me = this;
        this.grid.collapseAll();
        Rally.data.ModelFactory.getModel({
            type: 'TestFolder',
            success: function(model) {
                model.load(item.get('_ref'), {
                    fetch: ['FormattedID', 'Name', 'ObjectID', 'Parent'],
                    callback: function(record) {
                        me._buildAncestorArray(record,[record]).then({
                            success: function(records) {
                                console.log("array:",records);
                                me._expandNode(records);
                            },
                            failure: function(msg) {
                                console.log("oops," + msg);
                            }
                        });
                    },
                    scope: this
                });
            }
        });

        
        
    },
    
    _expandNode: function(ancestor_array) {
        this.setLoading("Expanding...");
        if ( ancestor_array.length > 0 ) {
            var top_record = ancestor_array[ancestor_array.length - 1];
            var node = this.grid.getStore().findExactRecord(top_record);

            if ( !node ) {
                this.setLoading(false);
                return;
            }
            
            if ( node && ancestor_array.length > 1) {
                ancestor_array.pop();
                
                if ( !node.isExpanded() ) {
                    node.on('expand', function() {
                        this._expandNode(ancestor_array);
                    }, this, {single: true});
                    node.expand(false);
                } else {
                    this._expandNode(ancestor_array);
                }
            } else {
                this.grid.getSelectionModel().select([node]);
                
                this.grid.getView().focusNode(node);

                this.setLoading(false);
            }
        }
    },
    
    // Ancestor array is in reverse order (top of tree is last item)
    _buildAncestorArray: function(record,ancestor_array) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        var parent = record.get("Parent");
        if ( parent ) {
            this._getFolderByObjectID(parent.ObjectID).then({
                success: function(records) {
                    var record = records[0];
                    ancestor_array.push(record);

                    me._buildAncestorArray(record,ancestor_array).then({
                        success: function(ancestors) {
                            deferred.resolve(ancestors);
                        },
                        failure: function(msg) {
                            deferred.reject(msg);
                        }
                    });
                },
                failure: function(msg) {
                    deferred.reject(msg);
                }
            });
        } else {
            deferred.resolve(ancestor_array);
        }
        return deferred.promise;
    },
    
    _getFolderByObjectID: function(objectID){
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            filters: [{property:'ObjectID',value:objectID}],
            fetch: ['FormattedID','Name','Parent','ObjectID'],
            model: 'TestFolder'
        }).load({
            callback : function(records, operation, successful) {
                if (successful){
                    deferred.resolve(records);
                } else {
                    deferred.reject('Problem getting folders: ' + operation.error.errors.join('. '));
                }
            }
        });
        return deferred.promise;
    },
    
    _addGrid: function() {
        var grid = this.add(this._getGridConfig());

        this.mon(grid, 'afterproxyload', this._onGridOrBoardLoad, this);

        if (!this.useFilterCollection && this.currentCustomFilter) {
            this._applyGridFilters(grid, this.currentCustomFilter);
        }
        
        this.on('recordSelect',this._showRecord, this);
        
        this.grid = grid;
        return grid;
    }
        
});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    /**
     * 
     * @param {String} A prefix to put into the message between
     *      the timestamp and the message
     */
    class_prefix: null,
    
    constructor: function(config){
        Ext.apply(this,config);
    },
    
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args.push(this._getClassPrefix(this.class_prefix));
        
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    },
    
    _getClassPrefix: function(prefix) {
        display_prefix = "";
        if ( Ext.isString(prefix) ) {
            display_prefix = "-" + prefix + "-";
        }
        
        return display_prefix;
    }

});

Ext.override(Rally.ui.menu.DefaultRecordMenu, {
    _getMenuItems: function() {
        var record = this.getRecord();
        var items = [];
        
        items.push({
            xtype: 'tsrecordmenuitemcascadedelete',
            view: this.view,
            record: record
        });
        
        return items;
    }
});

Ext.override(Rally.ui.menu.TestCaseRecordMenu, {
    _getMenuItems: function() {
        var record = this.getRecord();
        var items = [];
        
//        items.push({
//            xtype: 'tsrecordmenuitemcascadedelete',
//            view: this.view,
//            record: record
//        });
        
        return items;
    }
});
Ext.override(Ext.data.TreeStore,{
    load: function(options) {        
        options = options || {};
        options.params = options.params || {};

        var me = this,
            node = options.node || me.tree.getRootNode(),
            callback = options.callback,
            scope = options.scope,
            operation;

        // If there is not a node it means the user hasnt defined a rootnode yet. In this case let's just
        // create one for them.
        if (!node) {
            node = me.setRootNode({
                expanded: true
            }, true);
        }

        // If the node we are loading was expanded, we have to expand it after the load
        if (node.data.expanded) {
            node.data.loaded = false;

            // Must set expanded to false otherwise the onProxyLoad->fillNode->appendChild calls will update the view.
            // We ned to update the view in the callback below.
            if (me.clearOnLoad) {
                node.data.expanded = false;
            }
            options.callback = function() {

                // If newly loaded nodes are to be added to the existing child node set, then we have to collapse
                // first so that they get removed from the NodeStore, and the subsequent expand will reveal the
                // newly augmented child node set.
                if (!me.clearOnLoad) {
                    node.collapse();
                }
                node.expand();

                // Call the original callback (if any)
                Ext.callback(callback, scope, arguments);
            }
        }

        // Assign the ID of the Operation so that a ServerProxy can set its idParam parameter,
        // or a REST proxy can create the correct URL
        options.id = node.getId();

        options = Ext.apply({
            action: 'read',
            filters: me.filters.items,
            sorters: me.getSorters(),
            node: options.node || node
        }, options);

        console.log('sorters:', me.getSorters());
        
        me.lastOptions = options;

        operation = new Ext.data.Operation(options);

        if (me.fireEvent('beforeload', me, operation) !== false) {
             if (me.clearOnLoad) {
                if(me.clearRemovedOnLoad) {
                    // clear from the removed array any nodes that were descendants of the node being reloaded so that they do not get saved on next sync.
                    me.clearRemoved(node);
                }
                // temporarily remove the onNodeRemove event listener so that when removeAll is called, the removed nodes do not get added to the removed array
                me.tree.un('remove', me.onNodeRemove, me);
                // remove all the nodes
                node.removeAll(false);
                // reattach the onNodeRemove listener
                me.tree.on('remove', me.onNodeRemove, me);
            }
            me.loading = true;

            if ( !me.isRootNode(options.node) && me.models && me.models.length == 2 ) {
                /* If we have two models and they 
                 * don't both descend from the artifact 
                 * type (like test folder), we want to run
                 * the query twice and combine the results.
                 * 
                 * We have to make two new operations because
                 * each run modifies it
                 */
                console.log('taking alternate route');
                
                var o1 = Ext.create('Ext.data.Operation', options);
                o1.id = null;
                var o2 = Ext.create('Ext.data.Operation', options);
                o2.id = null;
                
                Deft.Chain.sequence([
                    function() {
                        var deferred = Ext.create('Deft.Deferred');
                        var model = me.models[1];
                        
                        o1.filters = me.filter_by_model[model.typePath];
                        o1.sorters = me.sorters_by_model[model.typePath];
                        
                        console.log('o1',model.typePath, o1);
                        
                        model.getProxy().read(o1,function(op){
                            deferred.resolve(op);
                        },me);
                        
                        return deferred.promise;
                    },
                    function() {
                        var deferred = Ext.create('Deft.Deferred');
                        var model = me.models[0];
                        
                        o2.filters = me.filter_by_model[model.typePath];
                        o2.sorters = me.sorters_by_model[model.typePath];
                    
                        console.log('o2:',model.typePath, o2);
                        
                        model.getProxy().read(o2,function(op){
                            deferred.resolve(op);
                        },me);
                        
                        return deferred.promise;
                    }
                ]).then({
                    scope: me,
                    success: function(operation){
                        var records = Ext.Array.merge(operation[0].getRecords(), operation[1].getRecords());
                        var results = Ext.create('Ext.data.ResultSet',{ records: records });
                        
                        operation[0].resultSet = results;
                        
                        me.onProxyLoad(operation[0]);
                    },
                    failure: function(msg){
                        alert(msg);
                    }
                
                });
                
            } else {
                me.proxy.read(operation, me.onProxyLoad, me);
            }
        }

        if (me.loading && node) {
            node.set('loading', true);
        }

        return me;
    }
});

Ext.override(Rally.data.wsapi.TreeStore,{
    
    load: function(options) {
        this.recordLoadBegin({description: 'tree store load', component: this.requester});
        
        this._hasErrors = false;

        this.on('beforeload', function(store, operation) {
            delete operation.id;
        }, this, { single: true });

        options = this._configureLoad(options);
        options.originalCallback = options.callback;

        var deferred = Ext.create('Deft.Deferred'),
            me = this;

        options.callback = function (records, operation, success) {
            me.dataLoaded = true;

            if(me.isRootNode(options.node) && operation.resultSet && operation.resultSet.sums) {
                me.setSums(operation.resultSet.sums);
            }

            if (me._pageIsEmpty(operation)) {
                me._reloadEmptyPage(options).then({
                    success: function (records) {
                        me._resolveLoadingRecords(deferred, records, options, operation, success);
                    },
                    failure: function() {
                        me._rejectLoadingRecord(deferred, options, operation);
                    }
                });
            } else {
                me._resolveLoadingRecords(deferred, records, options, operation, success);
            }
        };

        if (this._isViewReady()) {
            this._beforeInitialLoad(options);
        }

        this.callParent([options]);
        
        return deferred.promise;
    },
    // when we run the queries, need to consolidate the results
    temp_records: null, 
    
    _resolveLoadingRecords: function(deferred, records, options, operation, success) {
        delete options.callback; // Don't call me again, Susan.

        if ( ! this.temp_records || this.temp_records == null) { 
            this.temp_records = records; 
        } else {
            records = Ext.Array.merge(this.temp_records,records);
            this.temp_records = null;
            this.fred = false;
            
            if (options.originalCallback) {
                Ext.callback(options.originalCallback, options.scope || this, [records, operation, success]);
            }

            deferred.resolve(records);
        }
    },
    
    filter_by_model: {},
    
    sorters_by_model: {
        'testfolder': [{property:'ObjectID'}],
        'testcase': [{property:'DragAndDropRank'}]
    
    },
    
    _getChildNodeFilters: function(node) {
        
        var parentType = node.self.typePath,
            childTypes = this._getChildTypePaths([parentType]),
            parentFieldNames = this._getParentFieldNames(childTypes, parentType);

        Ext.Array.each(childTypes, function(childType){            
            var parentFieldName = this.mapper.getParentFieldForChild(childType,parentType);
            
            if ( parentFieldName ) {
                this.filter_by_model[childType] = [ Ext.create('Rally.data.wsapi.Filter',{
                    property: parentFieldName,
                    operator: '=',
                    value: node.get('_ref')
                }) ];
            }
        },this);
        
        if (parentFieldNames.length) {
            return [
                Rally.data.wsapi.Filter.or(_.map(parentFieldNames, function(parentFieldName) {
                    return {
                        property: parentFieldName,
                        operator: '=',
                        value: node.get('_ref')
                    };
                }))
            ];
        }
        
        return [];
    },
    
    _getRankField: function(model) {
        console.log("Model:",model);
        return Rally.data.Ranker.getRankField(model);
    },
    
    _getDefaultChildSorters: function() {
            return [
                {
                    property: 'TaskIndex',
                    direction: 'ASC'
                },
                {
                    property: this._getRankField(this.model),
                    direction: 'ASC'
                }];
        }
        
});

// test folders aren't artifacts
Ext.override(Rally.data.wsapi.ModelBuilder,{
    buildCompositeArtifact: function(models, context, wsapiVersion) {
        
        var typePath = 'testfolder',
            displayName = 'TestFolder',
            typeDefMetaData = Ext.create('Rally.data.TypeDefinitionMetaData', {
                requested: typePath,
                context: context,
                wsapiVersion: wsapiVersion
            }),
            typeDefinition = {
                Attributes: this._getAttributeDefinitionsFromModels(models),
                TypePath: typePath,
                DisplayName: displayName,
                Parent: null,
                ElementName: displayName,
                Restorable: false
            };
        
        var model = this.build(typeDefMetaData, typeDefinition);

        model.getArtifactComponentModels = function() {
            return models;
        };

        model.getModelsForField = function(field) {
            return _.transform(this.getArtifactComponentModels(), function(matchingModels, model) {
                if (_.find(model.getFields(), {name: field.name})){
                   matchingModels.push(model);
                }
            }, []);
        };

        var modelsByType = _.indexBy(model.getArtifactComponentModels(), 'typeName');
        
        model.getArtifactComponentModel = function(type) {
            var canonicalType = type.toLowerCase();
            return modelsByType[canonicalType];
        };
        return model;
    },
    
    /*
     * given the typedef response from the wsapi, build an Ext Model
     * @param {Rally.data.TypeDefinitionMetaData} typeDefMetaData TypeDefinition MetaData
     * @param {Object} typeDefinition The JSON representation of a Type Definition as
     *                                responded by the server
     */
    build: function(typeDefMetaData, typeDefinition) {
        var attributes = typeDefinition.Attributes,
            commonWsapiFields = _.map(
                Rally.data.FieldFactory.getCommonWsapiFields().concat(Rally.data.FieldFactory.getVirtualWsapiFields(typeDefinition)),
                this._createWsapiField
            ),
            fields = commonWsapiFields.concat(
                Rally.data.FieldFactory.buildFieldsFromTypeDefinitionAttributes(attributes)
            ),
            validations = Rally.data.FieldFactory.buildValidationsFromTypeDefinitionAttributes(attributes),
            typePath = typeDefinition.TypePath,
            metadataTypePath = typeDefMetaData.getTypePath().toLowerCase();

        _.each(fields, function(field) {
            field.modelType = typePath.toLowerCase();
        });

        return Ext.define(typeDefMetaData.getFullyQualifiedName(), {
            extend: 'Rally.data.wsapi.Model',
                fields: fields,
                validations: validations,
                statics: {
                    /**
                     * E.g., 'hierarchicalrequirement' or 'defect' or 'testcase'
                     */
                    typeName: metadataTypePath,

                    /**
                     * Type typeName, but replaces hierarchicalrequirment with userstory. Useful when building URLs
                     */
                    prettyTypeName: metadataTypePath === 'hierarchicalrequirement' ? 'userstory' : metadataTypePath,

                    /**
                     * E.g., 'portfolioitem/theme' or 'defect'
                     */
                    typePath: typePath.toLowerCase(),

                    /**
                     * E.g., 'User Story'
                     */
                    displayName: typeDefinition.DisplayName,

                    /**
                     * E.g., 'Portfolio Item' if a Theme
                     */
                    parentTypeName: typeDefinition.Parent && typeDefinition.Parent._refObjectName,

                    /**
                     * E.g., 'Theme' or 'HierarchicalRequirement'
                     */
                    elementName: typeDefinition.ElementName,

                    /**
                     * If a Dynamic Type (like Feature, a type of Portfolio Item), contains the level, e.g. 0 if the lowest
                     * -1 if not a dynamic type, like Defect.
                     */
                    ordinal: typeDefinition.Ordinal,
                    /**
                     * E.g.
                     * { workspace: '/workspace/123' }
                     */
                    context: typeDefMetaData.context,
                    /**
                     * E.g. true if a delete of this type should move it to the recycle bin
                     */
                    restorable: typeDefinition.Restorable,

                    /**
                     * E.g. 1.37 - the wsapi version from which this model was built
                     */
                    wsapiVersion: typeDefMetaData.wsapiVersion,

                    /**
                     * The ObjectID of the type definition the model was built by
                     */
                    typeDefOid: typeDefinition.ObjectID,

                    /**
                     * The name of type definition
                     */
                    typeDefName: typeDefinition.Name
                },

                proxy: Rally.data.wsapi.ModelFactory.buildProxy(Rally.data.wsapi.ModelFactory.buildProxyUrl(typePath, typeDefMetaData.wsapiVersion), typeDefinition.ElementName, null, typeDefMetaData.wsapiVersion)
            });
    }
});

// override treegrid so that all the models can be given to the picker
Ext.override(Rally.ui.grid.TreeGrid, {
    getModels: function() {        
        return this.store.models || [this.store.model];
    }
});
Ext.define('Rally.technicalservices.dialog.BulkAddToTestSetDialog',{
    extend: 'Rally.ui.dialog.ArtifactChooserDialog',
    alias: 'widget.tsaddtotestsetdialog',
    
    config: {
        autoShow: true,
        title: 'Choose a TestSet',
        artifactTypes: 'TestSet',
        multiple: false,
        
        columns: [
            {
                text: 'ID',
                dataIndex: 'FormattedID',
                renderer: _.identity
            },
            'Name',
            'Iteration',
            'Project'
        ]
    }
    
});
Ext.define('Rally.technicalservices.TFParentChildMapper',{
    extend: 'Rally.data.wsapi.ParentChildMapper',
    constructor: function() {
        this.parentChildTypeMap = {
            testfolder: [
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestFolder'},
                {typePath: 'testfolder', collectionName: 'Children', parentField: 'Parent'}
            ],
            hierarchicalrequirement: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'Requirement'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'},
                {typePath: 'hierarchicalrequirement', collectionName: 'Children', parentField: 'Parent'}
            ],
            defect: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            defectsuite: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'DefectSuites'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            testset: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestSets'}
            ]
        };
    },
    
    getParentFieldForChild: function(childType,parentType) {        
        var map_array = this.parentChildTypeMap[parentType];
        var parent_field = null;
        if (map_array) {
            Ext.Array.each(map_array, function(map){
                if ( map.typePath == childType && map.parentField ) {
                    parent_field =  map.parentField;
                }
            });
        }
        
        return parent_field;
        
    }
});

/**
 * A dialog that displays test folders to choose from
 *
 *     @example
 *     Ext.create('Rally.technicalservices.TestFolderChooserDialog', {
 *         autoShow: true,
 *         height: 250,
 *         title: 'Choose User Stories',
 *         listeners: {
 *             artifactchosen: function(dialog, selectedRecord){
 *                 Ext.Msg.alert('Chooser', selectedRecord.get('Name') + ' was chosen');
 *             },
 *             scope: this
 *         }
 *      });
 */
Ext.define('Rally.technicalservices.TestFolderChooserDialog', {
    requires: [
        'Ext.data.Store',
        'Rally.data.ModelFactory',
        'Rally.data.wsapi.Filter',
        'Rally.ui.Button',
        'Rally.ui.EmptyTextFactory',
        'Rally.ui.grid.Grid',
        'Rally.ui.selection.CheckboxModel',
        'Rally.util.Ref'
    ],
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tstestfolderchooserdialog',

    clientMetrics: [
        {
            method: '_search',
            description: 'chooser search performed'
        },
        {
            event: 'artifactchosen',
            description: 'artifact chosen'
        }
    ],

    height: 400,
    width: 600,
    layout: 'fit',
    closable: true,
    draggable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose a TestFolder',

        artifactTypes: ['testfolder'],
        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: false,

        /**
         * @cfg {Object}
         * An {Ext.data.Store} config object used when building the grid
         * Handy when you need to limit the selection with store filters
         */
        storeConfig: {
            fetch: ['FormattedID','Name','Parent','ObjectID'],
            compact: false,
            context: {
                project: null,
                projectScopeDown: false,
                projectScopeUp: false
            },
            sorters: [
                {
                    property: 'FormattedID',
                    direction: 'DESC'
                }
            ]
        },

        /**
         * @cfg {Ext.grid.Column}
         * List of columns that will be used in the chooser
         */
        columns: [
            {
                text: 'ID',
                dataIndex: 'FormattedID',
                renderer: _.identity
            },
            'Name'
        ],

        /**
         * @cfg {String}
         * Text to be displayed on the button when selection is complete
         */
        selectionButtonText: 'Done',

        /**
         * @cfg {Object}
         * The grid configuration to be used when creative the grid of items in the dialog
         */
        gridConfig: {},

        /**
         * @deprecated
         * @cfg {String}
         * The ref of a record to select when the chooser loads
         * Use selectedRecords instead
         */
        selectedRef: undefined,

        /**
         * @cfg {String}|{String[]}
         * The ref(s) of items which should be selected when the chooser loads
         */
        selectedRecords: undefined,

        /**
         * @cfg {Array}
         * The records to select when the chooser loads
         */
        initialSelectedRecords: undefined,

        /**
         * @private
         * @cfg userAction {String} (Optional)
         * The client metrics action to record when the user makes a selection and clicks done
         */

        /**
         * @cfg showRadioButtons {Boolean}
         */
        showRadioButtons: true
    },

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    selectionCache: [],

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event artifactchosen
             * Fires when user clicks done after choosing an artifact
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'artifactchosen'
        );

        this.addCls(['chooserDialog', 'chooser-dialog']);
    },

    destroy: function() {
        this._destroyTooltip();
        this.callParent(arguments);
    },

    beforeRender: function() {
        this.callParent(arguments);

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'doneButton',
                    text: this.selectionButtonText,
                    cls: 'primary rly-small',
                    scope: this,
                    disabled: true,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('artifactchosen', this, this.getSelectedRecords());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        if (this.introText) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                html: this.introText
            });
        }

        this.addDocked({
            xtype: 'toolbar',
            itemId: 'searchBar',
            dock: 'top',
            border: false,
            padding: '0 0 10px 0',
            items: this.getSearchBarItems()
        });

        this.buildGrid();

        this.selectionCache = this.getInitialSelectedRecords() || [];
    },

    /**
     * Get the records currently selected in the dialog
     * {Rally.data.Model}|{Rally.data.Model[]}
     */
    getSelectedRecords: function() {
        return this.multiple ? this.selectionCache : this.selectionCache[0];
    },

    getGridModels: function() {
        return this.artifactTypes;
    },

    getSearchBarItems: function() {
        return [
            {
                xtype: 'triggerfield',
                cls: 'rui-triggerfield chooser-search-terms',
                emptyText: 'Search Keyword or ID',
                enableKeyEvents: true,
                flex: 1,
                itemId: 'searchTerms',
                listeners: {
                    keyup: function (textField, event) {
                        if (event.getKey() === Ext.EventObject.ENTER) {
                            this._search();
                        }
                    },
                    afterrender: function (field) {
                        field.focus();
                    },
                    scope: this
                },
                triggerBaseCls: 'icon-search chooser-search-icon'
            }
        ];
    },

    getStoreFilters: function() {
        return [];
    },

    buildGrid: function() {
        if (this.grid) {
            this.grid.destroy();
        }

        var me = this;
        var selectionConfig = {
            mode: this.multiple ? 'SIMPLE' : 'SINGLE',
            allowDeselect: true
        };
        this.grid = Ext.create('Rally.ui.grid.Grid', Ext.Object.merge({
            autoAddAllModelFieldsAsColumns: false,
            columnCfgs: this.columns,
            enableEditing: false,
            enableColumnHide: false,
            enableColumnMove: false,
            model: this.getGridModels(),
            selModel: this.showRadioButtons || this.multiple ? Ext.create('Rally.ui.selection.CheckboxModel', Ext.apply(selectionConfig, {
                enableKeyNav: false,
                isRowSelectable: function (record) {
                    return me._isArtifactEditable(record);
                }
            })) : Ext.create('Ext.selection.RowModel', selectionConfig),
            showRowActionsColumn: false,
            storeConfig: this._getStoreConfig(),
            viewConfig: {
                emptyText: Rally.ui.EmptyTextFactory.get('defaultText'),
                publishLoadMessages: false,
                getRowClass: function (record) {
                    return Rally.util.Test.toBrowserTestCssClass('row', record.getId()) + (me._isArtifactEditable(record) ? ''  : ' disabled-row');
                }
            }
        }, this.config.gridConfig));
        this.mon(this.grid, {
            beforeselect: this._onGridSelect,
            beforedeselect: this._onGridDeselect,
            load: this._onGridLoad,
            scope: this
        });
        this.add(this.grid);
        this._onGridReady();
    },

    _addTooltip: function() {
        this._destroyTooltip();
        this.tooltip = Ext.create('Rally.ui.tooltip.ToolTip', {
            target: this.grid.getEl(),
            html: 'You don\'t have permission to edit this item.',
            delegate: '.disabled-row',
            anchor: 'top',
            showDelay: 0,
            showOnClick: true
        });
    },

    _destroyTooltip: function() {
        if (this.tooltip) {
            this.tooltip.destroy();
        }
    },

    _getStoreConfig: function() {
        var storeConfig = _.cloneDeep(this.getInitialConfig().storeConfig);

        if (this._getSearchTerms()) {
            storeConfig.search = this._getSearchTerms();
        }

        storeConfig.filters = (storeConfig.filters || []).concat(this.getStoreFilters());

        return storeConfig;
    },

    _enableDoneButton: function() {
        this.down('#doneButton').setDisabled(this.selectionCache.length ? false : true);
    },

    _findRecordInSelectionCache: function(record){
        return _.findIndex(this.selectionCache, function(cachedRecord) {
            return cachedRecord.get('_ref') === record.get('_ref');
        });
    },

    _onGridSelect: function(selectionModel, record) {
        if (!this._isArtifactEditable(record)) {
            return;
        }

        var index = this._findRecordInSelectionCache(record);
        if (index === -1) {
            if (!this.multiple) {
                this.selectionCache = [];
            }
            this.selectionCache.push(record);
        }

        this._enableDoneButton();
    },

    _onGridDeselect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);
        if (index !== -1) {
            this.selectionCache.splice(index, 1);
        }

        this._enableDoneButton();
    },

    _onGridReady: function() {
        if (!this.grid.rendered) {
            this.mon(this.grid, 'afterrender', this._onGridReady, this, {single: true});
            return;
        }

        if (this.grid.getStore().isLoading()) {
            this.mon(this.grid, 'load', this._onGridReady, this, {single: true});
            return;
        }

        this._onGridLoad();
        this.center();
    },

    _isArtifactEditable: function(record) {
        return Rally.environment.getContext().getPermissions().isProjectEditor(record.get('Project'));
    },

    _onGridLoad: function() {
        var defaultSelection = Ext.Array.from(this.selectedRef || this.selectedRecords);
        if (defaultSelection.length) {
            var selectedRecords = _.compact(_.map(defaultSelection, function(ref) {
                var recordIndex = this.grid.getStore().find('_ref', ref);
                return recordIndex >= 0 ? this.grid.getStore().getAt(recordIndex) : null;
            }, this));
            if(selectedRecords.length) {
                this.grid.getSelectionModel().select(selectedRecords);
            }
        } else {
            var store = this.grid.store;
            var records = [];

            _.each(this.selectionCache, function(record) {
                var recordIndex = store.find('_ref', record.get('_ref'));

                if (recordIndex !== -1) {
                    var storeRecord = store.getAt(recordIndex);
                    records.push(storeRecord);
                }
            });

            if (records.length) {
                this.grid.getSelectionModel().select(records);
            }
        }

        this._addTooltip();
        if (Rally.BrowserTest) {
            Rally.BrowserTest.publishComponentReady(this);
        }
    },

    _search: function() {
        var terms = this._getSearchTerms();
        var store = this.grid.getStore();

        if ( terms ) {
            var filters = Rally.data.wsapi.Filter.or([
                {property:"Name",operator:"contains",value:terms},
                {property:"FormattedID",operator:"contains",value:terms}
            ]);
            store.setFilter(filters);
        } else {
            store.clearFilter(true);
        }
        store.loadPage(1);
    },

    _getSearchTerms: function() {
        var textBox = this.down('#searchTerms');
        return textBox && textBox.getValue();
    }
});

/**
 * Adds a button for an artifact search box to a Rally.ui.gridboard.GridBoard.
 *
 */
Ext.define('Rally.technicalservices.GridBoardSearchControl', {
    alias: 'plugin.tsgridboardsearchcontrol',
    extend:'Ext.AbstractPlugin',
    mixins: ['Rally.ui.gridboard.plugin.GridBoardControlShowable'],
    requires: [
        'Rally.data.ModelTypes'
    ],
    headerPosition: 'right',

    /**
     * @cfg {Object}
     * Config for button.
     */
    searchControlConfig: {},

    containerConfig: {},

    init: function(gridboard) {
        this.callParent(arguments);
        this.gridboard = gridboard;

        this.context = this.searchControlConfig.context || this.gridboard.getContext();
        
        var control = this.showControl();
        this.searchButton = control.down('rallybutton');
        
    },

    getControlCmpConfig: function() {
        var me = this;
        var config = Ext.merge({
            xtype: 'container',
            width: 72,
            layout: 'hbox',
            items: [
                Ext.merge({
                    xtype: 'rallybutton',
                    text: '<span class="icon-search ">&nbsp;</span>',
                    cls: 'secondary rly-small',
                    listeners: {
                        scope: me,
                        click: me._showSearchDialog,
                        boxready: me._applyFilter
                    },
                    toolTipConfig: {
                        html: 'Search',
                        anchor: 'top',
                        mouseOffset: [-9, -2]
                    },
                    margin: '3 9 3 30'
                }, this.searchControlConfig)
            ]
        }, this.containerConfig);

        return config;
    },

    _showSearchDialog: function() {
        Ext.create('Rally.technicalservices.TestFolderChooserDialog',{
            autoShow: true,
            storeConfig: {
                context: this.context
            },
            listeners: {
                scope: this,
                artifactchosen: this._onRecordSelected
            }
        });
    },

    // always force to default filter
    _applyFilter: function() {
        var filterArgs = {
                types: [],
                filters: []
            };
        this.gridboard.applyCustomFilter(filterArgs);
    },

    _getTypesByNames: function(modelNames) {
        return _.map(modelNames, function (modelName) {
                return Rally.data.ModelTypes.getTypeByName(modelName).toLowerCase();
            }, this);
    },
    
    _onRecordSelected: function(dialog, record) {
        console.log("found: ", record);
        this.gridboard.fireEvent('recordSelect', record);
    }
});


Ext.define('TestFolderNavigator', {
        extend: 'Rally.app.GridBoardApp',
        cls: 'testfolder-app',
        modelNames: ['TestFolder'],
        statePrefix: 'ts-testfolder',

        enableXmlExport: false,

                
        logger: Ext.create('Rally.technicalservices.Logger'),
        
        getPermanentFilters: function () {
            return [
                Rally.data.wsapi.Filter.or([
                    { property: 'Parent', operator: '=', value: "" }
                ])
            ];
        },

        getFieldPickerConfig: function () {
            var config = this.callParent(arguments);
            config.gridFieldBlackList = _.union(config.gridFieldBlackList, [
                'VersionId',
                'Parent',
                'TestCases',
                'Recycled',
                'TestFolder',
                'Steps',
                'Objective',
                'PostConditions',
                'PreConditions',
                'Results',
                'TestSets',
                'ValidationExpectedResult',
                'ValidationInput'
            ]);
            return _.merge(config, {
               _getModels: function() {
                    console.log('models for picker', this.cmp.getModels());
                    
                    return _.reduce(this.cmp.getModels(), function(accum, model) {
                        if (model.typePath === 'artifact') {
                            accum = accum.concat(model.getArtifactComponentModels());
                        } else {
                            accum.push(model);
                        }
                        return accum;
                    }, []);
                },
                gridAlwaysSelectedValues: ['FormattedID','Name']
            });
        },
        
        getGridStores: function () {
            return this._getTreeGridStore();
        },
        
        _getTreeGridStore: function () {
            return Ext.create('Rally.data.wsapi.TreeStoreBuilder').build(_.merge({
                autoLoad: false,
                sorters: [{ property: 'ObjectID', direction: 'ASC'}],
                childPageSizeEnabled: true,
                mapper: Ext.create('Rally.technicalservices.TFParentChildMapper'),
                enableHierarchy: true,
                fetch: _.union(['Workspace'], this.columnNames),
                models: _.clone(this.models),
                pageSize: 25,
                remoteSort: true,
                root: {expanded: true},
//                storeType: 'Rally.technicalservices.data.wsapi.testfolder.Store',
                getParentFieldNamesByChildType: this._getParentFieldNamesByChildType,
                childLevelSorters: [{ property: 'FormattedID',direction: 'ASC'}]

            }, this.getGridStoreConfig())).then({
                success: function (treeGridStore) {
                    this.logger.log(treeGridStore);
                    treeGridStore.enableHierarchy = true;
                    //treeGridStore.on('load', this.publishComponentReady, this, { single: true });
                    return { gridStore: treeGridStore };
                },
                scope: this
            });
        },

        _getParentFieldNamesByChildType: function(childType, parentType) {
            var model = this.model.getArtifactComponentModel(childType);
            return(['Parent']);
            return _.transform(this.mapper.getParentFields(childType, parentType), function(acc, field) {
                var typePath = field.typePath,
                    fieldName = field.fieldName,
                    hasFieldModel = this.model.getArtifactComponentModel(typePath) || model.hasField(fieldName);

                if (hasFieldModel) {
                    acc.push(fieldName.replace(/\s+/g, ''));
                }
            }, [], this);
            
        },
        
        getAddNewConfig: function () {
            return Ext.merge(this.callParent(arguments), {
                showRank: false,
                showAddWithDetails: false,
                openEditorAfterAddFailure: false,
                minWidth: 800
            });
        },
        
        getGridBoardPlugins: function () {
            return [
//                {
//                    ptype: 'rallygridboardaddnew',
//                    context: this.getContext()
//                },
                {
                    ptype: 'tsgridboardsearchcontrol',
                    searchControlConfig: Ext.Object.merge({},this.getSearchControlConfig())
                },
                _.merge({
                    ptype: 'rallygridboardfieldpicker',
                    headerPosition: 'left'
                }, this.getFieldPickerConfig())
            ]
            .concat(this.enableGridBoardToggle ? 'rallygridboardtoggleable' : [])/*
            .concat(this.getActionsMenuConfig())*/;
        },

        getSearchControlConfig: function() {
            return {};
        },
        
        getGridConfig: function (options) {
            return {
                xtype: 'rallytreegrid',
                alwaysShowDefaultColumns: false,
                columnCfgs: this.getColumnCfgs(),
                enableBulkEdit: true,
                enableRanking: Rally.data.ModelTypes.areArtifacts(this.modelNames),
                expandAllInColumnHeaderEnabled: true,
                plugins: this.getGridPlugins(),
                stateId: this.getScopedStateId('grid'),
                stateful: true,
                store: options && options.gridStore,
                storeConfig: {
                    autoLoad: true,
                    filters: this.getPermanentFilters()
                },
                useFilterCollection: false,
                summaryColumns: [],
                listeners: {
                    afterrender: this.publishComponentReady,
                    storeload: {
                        fn: function () {
                            this.fireEvent('contentupdated', this);
                        },
                        single: true
                    },
                    scope: this
                }
            };
        }
    });
            
               Rally.launchApp('TestFolderNavigator', {
                   name: 'Test Folder Navigator'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>